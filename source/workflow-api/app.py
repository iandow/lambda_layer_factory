from chalice import Chalice
from chalice import BadRequestError, ChaliceViewError
import boto3
from boto3.dynamodb.conditions import Key
from boto3.dynamodb.conditions import Attr
from boto3 import resource
from botocore.client import ClientError
import uuid
import logging
import os
from datetime import date
from datetime import time
from datetime import datetime
import json
import time
import decimal

app = Chalice(app_name='workflow-api')

# Setup logging
logger = logging.getLogger('boto3')
logger.setLevel(logging.INFO)

# table names generated by CloudFormation
WORKFLOW_TABLE_NAME = "Workflow"
STAGE_TABLE_NAME = "stage"
WORKFLOW_EXECUTION_TABLE_NAME = "workflow_execution"
STAGE_EXECUTION_LAMBDA_ARN = "arn:aws:lambda:us-east-1:526662735483:function:stage_execution_lambda"
STAGE_EXECUTION_ROLE_ARN = "arn:aws:iam::526662735483:role/stage_execution_lambda_role"
ANALYSIS_STAGE_STATE_MACHINE_ARN = "arn:aws:states:us-east-1:526662735483:stateMachine:media-analysis-state-machine"
#WORKFLOW_TABLE_NAME = os.environ["WORKFLOW_TABLE_NAME"]
#STAGE_TABLE_NAME = os.environ["STAGE_TABLE_NAME"]
#WORKFLOW_EXECUTION_TABLE_NAME = os.environ["WORKFLOW_EXECUTION_TABLE_NAME"]
#STAGE_EXECUTION_LAMBDA_ARN = os.environ["STAGE_EXECUTION_LAMBDA_ARN"]
#STAGE_EXECUTION_ROLE_ARN = os.environ["STAGE_EXECUTION_ROLE_ARN"]

# DynamoDB
DYNAMO_CLIENT = boto3.client("dynamodb")
DYNAMO_RESOURCE = boto3.resource("dynamodb")

# Step Functions
SFN_FUNCTION_CLIENT = boto3.client('stepfunctions')

# Helper class to convert a DynamoDB item to JSON.
class DecimalEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, decimal.Decimal):
            return str(o)
        return super(DecimalEncoder, self).default(o)

def results_pager(list_function, list_locator, attr_transform):
    results = []
    next_token = None
    try:
        while True:
            if next_token is None or len(next_token) == 0:
                service_response = list_function()
            else:
                service_response = list_function(NextToken=next_token)
            results = results + list_locator(service_response)
            # check the paging token
            if "NextToken" in service_response:
                next_token = service_response["NextToken"]
            else:
                break
            if len(next_token) == 0:
                break
        for item in results:
            item = attr_transform(item)
    except Exception as e:
        print(e)
    return results

@app.route('/')
def index():
    return {'hello': 'world'}

@app.route('/workflow', cors=True, methods=['POST'])
def create_workflow():
    workflowId = "Default"
    table_name = WORKFLOW_TABLE_NAME

    try:
        table = DYNAMO_RESOURCE.Table(table_name)
        
        print(app.current_request.json_body)
        workflow = app.current_request.json_body

        # build state machine for workflow
        workflowASL = {
            "Comment": "Workflow created from create_workflow() API",
            "StartAt" : workflow["stages"][0]["name"],
            "States" : {}
        }
        
        endStageName = workflow["stages"][-1]["name"]

        for i in range(len(workflow["stages"])):
            stage = workflow["stages"][i]
            
            #stageDefinition = get_stage(stage["name"])
            stageDefintion = {
                "stateMachineArn":ANALYSIS_STAGE_STATE_MACHINE_ARN
            }
            
            
            workflowASL["States"][stage["name"]] = {
                "Type": "Task",
                "Resource": STAGE_EXECUTION_LAMBDA_ARN,
                "Parameters": {
                    "workflowId":workflowId,
                    "stageStateMachineArn": stageDefintion["stateMachineArn"]
                },
                "TimeoutSeconds": 300
            }

            if stage["name"] == endStageName:
                workflowASL["States"][stage["name"]]["End"] = True
            else:
                workflowASL["States"][stage["name"]]["Next"] = workflow["stages"][i+1]["name"] 

        # create the state machine for the workflow
        try:
            print(json.dumps(workflowASL))
            sfn_response = SFN_FUNCTION_CLIENT.create_state_machine(
                name=workflow['name'],
                definition=json.dumps(workflowASL),
                roleArn=STAGE_EXECUTION_ROLE_ARN
            )

            workflow['stateMachine'] = sfn_response
            workflow['createTime'] = int(time.time())
            
        except Exception as e:
            logger.info("Exception {}".format(e))
            raise ChaliceViewError("Exception '%s'" % e)

        table.put_item(item=workflow)  

    except Exception as e:
        logger.info("Exception {}".format(e))
        raise ChaliceViewError("Exception '%s'" % e)

    return workflow

@app.route('/workflow/{workflowId}')
def get_workflow_by_id():
    response = {}
    return response

@app.route('/workflow')
def get_workflow():
    response = {}
    return response

@app.route('/stage')
def create_stage():
    response = {}
    return response



default_workflow = {
        "name":"default",
        "stateMachineArn": "",
        "stages": [
            {
            "name":"Preprocess",
            "configuration":{}
            },
            {
            "name":"Analysis",
            "configuration":{}
            },
            {
            "name":"Postprocess",
            "configuration":{}
            }
        ]
    }


# The view function above will return {"hello": "world"}
# whenever you make an HTTP GET request to '/'.
#
# Here are a few more examples:
#
# @app.route('/hello/{name}')
# def hello_name(name):
#    # '/hello/james' -> {"hello": "james"}
#    return {'hello': name}
#
# @app.route('/users', methods=['POST'])
# def create_user():
#     # This is the JSON body the user sent in their POST request.
#     user_as_json = app.current_request.json_body
#     # We'll echo the json body back to the user in a 'user' key.
#     return {'user': user_as_json}
#
# See the README documentation for more examples.
#
